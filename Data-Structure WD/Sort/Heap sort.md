## 堆排序

### 堆的含义

若n个关键字序列L[1...n]满足下面的某一条性质, 则称为堆(heap)
1. 若满足: L(i)≥L(2i)且L(i)≥L(2i+1) (1≤i≤n/2) -- 大根堆(大顶堆)
2. 若满足: L(i)≤L(2i)且L(i)≤L(2i+1) (1≤i≤n/2) -- 小根堆(小顶堆)

- 大根堆: 简单的说, 就是完全二叉树中, 根≥左, 右
- 小根堆: 简单的说, 就是完全二叉树中, 根≤左, 右
- 上述可以对比BST

### 二叉树的顺序存储

几个重要常考的基本操作:
- i的左孩子 -- 2i
- i的右孩子 -- 2i+1
- i的父结点 -- ⌊i/2⌋
- i所在的层次 -- ⌈log2(n+1)⌉或⌊log2n⌋+1

若完全二叉树中共有n个结点, 则
- 判断i是否有左孩子? -- 2i≤n?
- 判断i是否有右孩子? -- 2i+1≤n?
- 判断i是否有叶子/分支结点? -- i>⌊n/2⌋?

### 建立大根堆

思路: 把所有的非终端结点都检查一遍, 是否满足大根堆的要求, 如果满足, 则进行调整. 在顺序存储的完全二叉树中, 非终端结点的编号i≤⌊n/2⌋. 检查当前的结点是否满足: 根≥左, 右; 若不满足, 将当前结点与更大的一个孩子进行互换, 若元素互换破坏了下一层的堆, 则采用相同的方法继续往下调整(小元素不断“下坠”)

#### 代码实现

```c
// 建立大根堆
void BuildMaxHeap(int A[], int len)
{
    for (int i = len / 2; i > 0; i--) // 从后往前调整所有非终端结点
    {
        HeadAdjust(A, i, len);
    }
}

// 将以k为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len)
{
    A[0] = A[k];                          // A[0]暂存子树的根结点
    for (int i = 2 * k; i <= len; i *= 2) // 沿key较大的子结点向下筛选
    {
        if (i < len && A[i] < A[i + 1])
        {
            i++; // 取key较大的子结点的下标
        }
        if (A[0] >= A[i]) // 筛选结束, 比左右子树中的值都大
        {
            break;
        }
        else // 如果A[0] < A[i]的情况
        {
            A[k] = A[i]; // 将A[i]调整到双亲结点上
            k = i;       // 修改k值, 以便继续向下筛选
        }
    }
    A[k] = A[0]; // 被筛选结点的值放入最终的位置
}
```

其中, 判断i < len的目的是判断是否有右子树, 如果没有的话, 不用比较左右子树的值

### 基于大根堆进行排序

每一趟将堆顶元素加入有序子序列(与待排序序列中的最后一个元素交换), 并将待排序元素序列再次调整为大根堆(小元素不断“下坠”)