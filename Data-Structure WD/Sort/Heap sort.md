## 堆排序

### 堆的含义

若n个关键字序列L[1...n]满足下面的某一条性质, 则称为堆(heap)
1. 若满足: L(i)≥L(2i)且L(i)≥L(2i+1) (1≤i≤n/2) -- 大根堆(大顶堆)
2. 若满足: L(i)≤L(2i)且L(i)≤L(2i+1) (1≤i≤n/2) -- 小根堆(小顶堆)

- 大根堆: 简单的说, 就是完全二叉树中, 根≥左, 右
- 小根堆: 简单的说, 就是完全二叉树中, 根≤左, 右
- 上述可以对比BST

### 二叉树的顺序存储

几个重要常考的基本操作:
- i的左孩子 -- 2i
- i的右孩子 -- 2i+1
- i的父结点 -- ⌊i/2⌋
- i所在的层次 -- ⌈log2(n+1)⌉或⌊log2n⌋+1

若完全二叉树中共有n个结点, 则
- 判断i是否有左孩子? -- 2i≤n?
- 判断i是否有右孩子? -- 2i+1≤n?
- 判断i是否有叶子/分支结点? -- i>⌊n/2⌋?

### 建立大根堆

思路: 把所有的非终端结点都检查一遍, 是否满足大根堆的要求, 如果满足, 则进行调整. 在顺序存储的完全二叉树中, 非终端结点的编号i≤⌊n/2⌋. 检查当前的结点是否满足: 根≥左, 右; 若不满足, 将当前结点与更大的一个孩子进行互换, 若元素互换破坏了下一层的堆, 则采用相同的方法继续往下调整(小元素不断“下坠”)

#### 代码实现

```c
// 建立大根堆
void BuildMaxHeap(int A[], int len)
{
    for (int i = len / 2; i > 0; i--) // 从后往前调整所有非终端结点
    {
        HeadAdjust(A, i, len);
    }
}

// 将以k为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len)
{
    A[0] = A[k];                          // A[0]暂存子树的根结点
    for (int i = 2 * k; i <= len; i *= 2) // 沿key较大的子结点向下筛选
    {
        if (i < len && A[i] < A[i + 1])
        {
            i++; // 取key较大的子结点的下标
        }
        if (A[0] >= A[i]) // 筛选结束, 比左右子树中的值都大
        {
            break;
        }
        else // 如果A[0] < A[i]的情况
        {
            A[k] = A[i]; // 将A[i]调整到双亲结点上
            k = i;       // 修改k值, 以便继续向下筛选
        }
    }
    A[k] = A[0]; // 被筛选结点的值放入最终的位置
}
```

其中, 判断i < len的目的是判断是否有右子树, 如果没有的话, 不用比较左右子树的值

### 基于大根堆进行排序

每一趟将堆顶元素加入有序子序列(与待排序序列中的最后一个元素交换), 并将待排序元素序列再次调整为大根堆(小元素不断“下坠”)

基于大根堆的堆排序序列得到的是"递增序列", 基于小根堆的堆排序序列得到的是"递减序列"

#### 代码实现

```c
// 堆排序的完整逻辑
void HeapSort(int A[], int len)
{
    BuildMaxHeap(A, len);         // 初始化堆
    for (int i = len; i > 1; i--) // 第n-1趟的交换和建堆的过程
    {
        swap(A[i], A[1]);        // 堆顶元素和堆底元素交换
        HeadAdjust(A, 1, i - 1); // 把剩余的待排序元素整理成堆
    }
}
```

用i来标记堆底元素

### 算法效率分析

#### 建堆

- 如果下方只有一个孩子, 则"下坠"一层, 只需要对比关键字1次. 
- 一个结点, 每"下坠"一层, 最多只需要对比关键字2次. 
- 若树高为h, 某结点在第i层, 则将这个结点向下调整最多只需要"下坠"h-i层, 关键字对比次数不超过2(h-i).
- n个结点的完全二叉树树高h=⌊log2n⌋+1.
- 第i层最多有2^(i-1)个结点, 而只有第1~(h-1)层的结点才有可能需要"下坠"调整
- 若整棵树调整为大根堆, 关键字对比次数不超过$\sum^{1}_{i=h-1}2^{i-1}2(h-i)=\sum^{h-1}_{j=1}2^{h-j}j$由于$h=⌊log_2n⌋+1$代入$h$得到$\sum^{h-1}_{j=1}2^{⌊log_2n⌋+1}2^{-j}j$, 由于$2^{⌊log_2n⌋+1}$为常数, 故可以提出, 得到$2^{⌊log_2n⌋+1}\sum^{h-1}_{j=1}2^{-j}j$, 由于$2^{⌊log_2n⌋+1}<2n$, 故$\sum^{h-1}_{j=1}2^{h-j}j≤2n\sum^{h-1}_{j=1}2^{-j}j≤4n$
- 建堆的过程, 关键字对比次数不超过4n, 建堆的时间复杂度=O(n)

#### 排序

- 总共需要n-1趟, 每一趟交换后都需要将根结点"下坠"调整
- 根结点最多"下坠"h-1层
- 每"下坠"一层, 最多只需要对比关键字2次, 因此每一趟排序复杂度不超过O(h)=O(log2n), 注意, h=⌊log_2n⌋+1
- 总共需要n-1趟的处理, 总的时间复杂度=O(nlog2n)

#### 建堆+排序

- 总的时间复杂度: O(n) + O(nlog2n) = O(nlog2n)
- 总的空间复杂度: O(1)

### 稳定性

不稳定