## 快速排序

### 基本思想

- 再待排序表L[1...n]中任取一个元素pivot作为枢轴(或基准, 通常取首元素), 通过一趟排序将排序表划分为两个独立的部分L[1...k-1]和[k+1...n], 使得L[1...k-1]中的所有元素小于pivot, L[k+1...n]中的所有元素大于等于pivot, 则pivot放在了其最终位置L(k)上, 这个过程被称为一次"划分". 然后分别递归地对两个子表重复上述的过程, 直至每部分内只有一个元素或空为止, 即所有元素放在了其最终位置上.

### 代码实现

```c
// 用第一个元素将待排序序列划分为左右两个部分
int Partition(int A[], int low, int high)
{
    int pivot = A[low]; // 将第一个元素作为枢轴
    while (low < high)  // 用low, high搜索枢轴的最终位置
    {
        while (low < high && A[high] >= pivot)
        {
            --high;
        }
        A[low] = A[high]; // 比枢轴小的元素移动到最左端
        while (low < high && A[low] <= pivot)
        {
            ++low;
        }
        A[high] = A[low]; // 比枢轴大的元素移动到最右端
    }
    A[low] = pivot; // 枢轴元素存放到最终位置
    return low;     // 返回存放枢轴的最终位置
}

// 快速排序
void QuickSort(int A[], int low, int high)
{
    if (low < high) // 递归跳出的条件
    {
        int pivotpos = Partition(A, low, high); // 划分
        QuickSort(A, low, pivotpos - 1);        // 划分左子表
        QuickSort(A, pivotpos + 1, high);       // 划分右子表
    }
}
```

需要借助函数调用栈

### 算法效率分析

- 时间复杂度: 每一层只需要处理剩余的待排元素, 时间复杂度不超过O(n), 所以时间复杂度为O(n*递归层数)
- 空间复杂度: O(递归深度)
- 最小递归深度: 可以将其转化为n个结点的二叉树, 最小高度为=⌊log2n⌋+1; 最大高度为n
- 最好时间复杂度: O(nlog2n)
- 最坏时间复杂度: O(n^2)
- 平均时间复杂度: O(nlog2n)
- 最好空间复杂度: O(log2n)
- 最坏空间复杂度: O(n)
- 快速排序是所有内部排序算法中平均性能最优秀的排序算法

#### 比较好的情况

若每一次选中的"枢轴"将待排序序列划分为均匀的两个部分, 则递归深度最小, 算法的效率最高

#### 最坏的情况

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |

若初始序列有序或者逆序, 则快速排序的性能最差(因为每次选择的都是最靠边的元素)

#### 快速排序算法优化思路

尽量选择可以把数据中分的枢轴元素
1. 选头, 中, 尾三个位置的元素, 取中间值作为枢轴元素
2. 随机选一个元素作为枢轴元素

### 稳定性

不稳定