## 简单选择排序

### 选择排序的基本思想

每一趟(如第i趟)在后面n-i+1(i=1, 2,..., n-1)个排序元素中选取关键字最小的元素, 作为有序子序列的第i个元素, 直到第n-1趟做完, 待排序元素只剩下一个, 就不用再选了

### 代码实现

```c
// 简单选择排序
void SelectSort(ElemType A[], int n)
{
    for (i = 0; i < n - 1; i++) // 一共进行n-1趟
    {
        int min = i;                // 记录最小元素的位置
        for (j = i + 1; j < n; j++) // 在A[i...n-1]中选择最小的元素
        {
            if (A[j] < A[min])
            {
                min = j; // 更新最小元素的位置
            }
        }
        if (min != i)
        {
            swap(A[i], A[min]); // 封装的swap()函数共移动元素3次
        }
    }
}

// 交换
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

### 算法性能分析

- 空间复杂度: 仅用常数个辅助单元, 所以空间复杂度为O(1)
- 时间复杂度: 无论有序、逆序还是乱序, 一定要经过n-1趟处理, 总共需要对比关键字(n-1)+(n-2)+...+1=n(n-1)/2次, 元素交换次数<n-1
- 稳定性: 不稳定
- 适用性: 既可用于顺序表, 也可用于链表
  