## 败者树

### 多路平衡归并带来的问题

- 外部排序时间开销 = 读写外存的时间 + 内部排序所需的时间 + 内部归并所需的时间
- 归并趟数S=⌈logkr⌉, 归并路数k增加, 归并趟数S减小, 读写磁盘总次数减少
- 使用k路归并策略, 选出一个最小的元素需要对比关键字次数为(k-1)次, 导致内部归并所需的时间增加(如8路平衡归并, 从8个归并段中选出最小元素需要对比关键字7次)
- 可以使用“败者树”进行优化!

### 败者树的含义

败者树——可以视为一颗完全二叉树(多了一个头). k个叶结点分别是当前参加比较的元素, 非叶结点用来记忆左右子树中的“失败者”, 而让胜者往上继续进行比较, 一直到根结点

### 败者树在多路平衡归并中的应用

![败者树的应用](https://github.com/Ricolxwz/Data-Structure/blob/main/IMG/Graph/Loser%20tree1.png)

- 分支结点记录失败败者来自哪个归并段
- 每个叶子结点对应一个归并段
- 根结点记录冠军来自那个归并段
- 新加入的元素和“败者”打
- 对于k路合并, 第一次构造败者树需要对比关键字k-1次
- 有了败者树, 选出最小的元素, 只需要对比关键字⌈log2k⌉次

### 败者树的实现思路

- k路归并的败者树只需要定义一个长度为k的数组即可
- 叶子结点是“虚拟”的
- 数组的第一个元素对应的是冠军元素