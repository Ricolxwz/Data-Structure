## BFS
### 要点
1. 找到与一个顶点相邻的所有顶点
   - `FirstNeighbor(G, x)`
   - `NextNeighbor(G, x, y)`
2. 标记哪些顶点被访问过
   - `bool visited[MAX_VERTEX_NUM]`
3. 需要一个辅助队列(有点类似于树的层遍历)

### 复杂度分析
空间复杂度: 最坏的情况, 辅助队列的大小为`O(|V|)`
<br>
时间复杂度: <br>
1. 邻接矩阵存储的图: 访问`|V|`个结点需要`O|V|`的时间, 查找每个顶点的邻接点需要`O(|V|)`的时间, 而总共有`|V|`个顶点, 所以时间复杂度 = `O(|V|^2)`
2. 访问`|V|`个顶点需要`O(|V|)`的时间, 查找各个顶点的邻接点共需要`O(|E|)`的时间, 所以时间复杂度 = `O(|V|+|E|)`, 注意这里如果是无向图的邻接表表示法的时候, 遍历边的时间复杂度应该是`O(2|E|)`, 但是2可以舍去

无论是广度优先遍历还是深度优先遍历, 时间开销都可以用找到顶点的时间开销和找到边的时间开销计算, 不用去代码中求出最深层的循环次数
### 广度优先生成树
广度优先生成树由广度优先遍历过程确定, 由于邻接表的表示方式不唯一, 因此基于邻接表的广度优先生成树也不唯一
### 广度优先生成森林
对非连通图的广度优先遍历, 可以得到广度优先生成森林
### 练习
有向图的BFS过程